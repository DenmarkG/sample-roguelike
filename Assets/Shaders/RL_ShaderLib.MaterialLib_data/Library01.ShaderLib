FILEVERSION = 2.4.0.0;
PLATFORM = DX9;

//////////////////////////////////////////////////////////////////////////////
SOURCECODE=$SOURCECODETAG{
// [This is mandatory comment line; Place your comment here.]
  }$SOURCECODETAG

//////////////////////////////////////////////////////////////////////////////

RENDER_STATE RSC_0 {
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_1 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_2 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_3 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_4 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_5 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_6 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_7 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_8 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_9 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_10 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_11 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_12 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_13 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_14 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_15 {
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_16 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_17 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_18 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_19 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_20 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_21 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  alphatestref = 64;
  dstblend = zero;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_22 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_23 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_24 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_25 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_26 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_27 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_28 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_29 {
  rasterizerstylefromsurface = true;
  trackingmask = 1;
  compiledClass = "VDynamicLightShader";

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;
  srcblend = src_alpha;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;
  depthcomparisonfunc = equal;

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

SHADER shader01.forward {
  RenderStateContainerID = 0;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


//- PERMUTATION MARKER -\\

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_default

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_default {
  RenderStateContainerID = 1;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_default

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_default

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_Fullbright {
  RenderStateContainerID = 2;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_Fullbright

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_Fullbright

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_Lightgrid {
  RenderStateContainerID = 3;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_Lightgrid

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_Lightgrid

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_LightgridSimple {
  RenderStateContainerID = 4;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_LightgridSimple

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_LightgridSimple

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_Lightmap {
  RenderStateContainerID = 5;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 4;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "Lightmap";
    texturetype = lightmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_Lightmap

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_Lightmap

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_LightmapDot3 {
  RenderStateContainerID = 6;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 6;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "Lightmap1";
    texturetype = lightmap;
    textureindex = 1;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 4 = {
    samplername = "Lightmap2";
    texturetype = lightmap;
    textureindex = 2;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 5 = {
    samplername = "Lightmap3";
    texturetype = lightmap;
    textureindex = 3;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_LightmapDot3

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_LightmapDot3

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_PointLight {
  RenderStateContainerID = 7;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 4;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_PointLight

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_PointLight

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_SpotLight {
  RenderStateContainerID = 8;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 5;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 4 = {
    samplername = "ProjTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = border,border,border;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_SpotLight

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_SpotLight

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_ProjPointLight {
  RenderStateContainerID = 9;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 5;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 4 = {
    samplername = "ProjTex";
    texturetype = cubemap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_ProjPointLight

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_ProjPointLight

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_DirectionalLight {
  RenderStateContainerID = 10;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_DirectionalLight

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_DirectionalLight

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_PointLight_Shadow {
  RenderStateContainerID = 11;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 4;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_PointLight_Shadow

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_PointLight_Shadow

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_SpotLight_Shadow {
  RenderStateContainerID = 12;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 5;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 4 = {
    samplername = "ProjTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = border,border,border;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_SpotLight_Shadow

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_SpotLight_Shadow

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_ProjPointLight_Shadow {
  RenderStateContainerID = 13;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 5;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 4 = {
    samplername = "ProjTex";
    texturetype = cubemap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_ProjPointLight_Shadow

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_ProjPointLight_Shadow

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER shader01.forward_DirectionalLight_Shadow {
  RenderStateContainerID = 14;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Normalmap";
    texturetype = normalmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "GlowMap";
    texturetype = custom;
    textureindex = 0;
    texturefile = "\flare07.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_DirectionalLight_Shadow

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_DirectionalLight_Shadow

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define USE_TANGENT
#define LIGHTING_FUNCTIONS
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif
#ifndef _VISION_DX10
			float GlowMultiplier : register(c69);
      #endif
#ifdef PREVIEW
			texture Normalmap; //TEX 
			sampler Normalmap_Sampler = 
			sampler_state
			{
			    Texture = <Normalmap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};			
			#else
			
			#ifdef _VISION_DX10
			Texture2D   Normalmap         : register(t1);
			sampler     Normalmap_Sampler  : register(s1);				
			#else
			sampler2D Normalmap : register(s1); //TEX 
			#endif
			#endif
#ifdef PREVIEW
			
			texture GlowMap; //TEX \flare07.dds
			sampler GlowMap_Sampler =
			sampler_state
			{
			    Texture = <GlowMap>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX10
			
			Texture2D GlowMap : register(t2);
			sampler GlowMap_Sampler : register (s2);
			#else
			sampler2D GlowMap : register(s2); //TEX \flare07.dds
			#endif
			
			#endif


#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t3);
				sampler Lightmap_Sampler : register(s3);
				#else
				sampler2D Lightmap : register(s3);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t4);
				Texture2D Lightmap2 : register(t5);
				Texture2D Lightmap3 : register(t6);
				
				sampler Lightmap1_Sampler : register(s4);
				sampler Lightmap2_Sampler : register(s5);
				sampler Lightmap3_Sampler : register(s6);

				#else
				sampler2D Lightmap1 : register(s4);
				sampler2D Lightmap2 : register(s5);
				sampler2D Lightmap3 : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					Texture2D ProjTex : register(t8);

					sampler AttenTex_Sampler : register(s7);
					sampler ProjTex_Sampler : register(s8);
				#else
					sampler2D AttenTex : register(s7);
					sampler2D ProjTex : register(s8);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t7);
					sampler AttenTex_Sampler : register(s7);
				#else
					sampler2D AttenTex : register(s7);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t9);
				TextureCube ProjTex : register(t8);	

				sampler AttenTex_Sampler : register(s7);
				sampler ProjTex_Sampler : register(s8);	
				#else
					sampler2D AttenTex : register(s7);
					samplerCUBE ProjTex : register(s8);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t10);
				sampler     ShadowTex_Sampler  : register(s9);
				#else
				sampler2D   ShadowTex         : register(s9);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    float GlowMultiplier : packoffset(c5);

	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.r
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.g
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.b
*/
/*!float
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085.a
*/
/*!float4
VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float
GlowMultiplier
*/
//! MARKER - 4a1ae54ba30a417b86ee614f04d33d56
#ifdef PREVIEW
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = tex2D( Normalmap_Sampler, In.UV0AND1.xy );
			#else			
			  float4 VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5 = vTex2D( Normalmap, Normalmap_Sampler, In.UV0AND1.xy );
			  float3 VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70 = VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.rgb * float3(2.f,2.f,2.f) - float3(1.f,1.f,1.f);
			  float3 VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4 = normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent));
			#endif
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.r
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.g
*/
/*!float
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4.b
*/
/*!float
VAR_NormalMap_b0ef9ef0ad4b43d5b48091f617a9fda5.a
*/
/*!float3
VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70
*/
/*!float3
VAR_NormalMap_a3d8bd17922b4665b43d5f3d440275e4
*/
//! MARKER - 4f881f4dfafa4cc983038bfa6a1c1d7d
#ifdef PREVIEW
			float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = tex2D( GlowMap_Sampler, In.UV0AND1.xy );
			#else
				float4 VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a = vTex2D( GlowMap, GlowMap_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.r
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.g
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.b
*/
/*!float
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a.a
*/
/*!float4
VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a
*/
//! MARKER - 5cfe04e25c3f4a8caeb55f3fbe9722d2
float4 VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf = (VAR_ParameterTexture_7574809eea324dd4976cc1d4f8802f1a * GlowMultiplier);
/*!float4
VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf
*/
//! MARKER - 07a2e9c78d45447d8220d97a39552f94
float4 VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf = saturate( VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf );
/*!float4
VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGrid( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightGridSimple( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085 * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83 = normalize(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70);
			float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_LightmapDot3( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, VAR_Lighting_47bcbc081b5d41abb9083401ef2d7e83, 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = float4(lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_PointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_Spotlight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_ProjPointLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158 = Lighting_DirectionalLight( VAR_BaseTexture_4bff1ce782894681b456c81f0e34f085, normalize(TangentToWorldSpace(VAR_NormalMap_ffd16a51bc7c4f93a094539007559f70, In.Normal, In.Tangent, In.BiTangent)), 64.0, float3( 1.0, 1.0, 1.0 ), 1.0, gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Glow_78efb456324e44768fbfa7564ba68f2a = lerp(VAR_Lighting_c5f2c7031e49449984c6dd6228e3f158, VAR_Multiply_55ec1201c9c54431a2bb3ae0c58db3bf, (dot(VAR_Saturate_767ee810b43b454dbf030eb3eed9ebdf.rgba, 0.25)));
/*!float4
VAR_Glow_78efb456324e44768fbfa7564ba68f2a
*/
//! MARKER - b8937ceaa6a94998b1d33ff4231f6fe0
return VAR_Glow_78efb456324e44768fbfa7564ba68f2a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward {
  RenderStateContainerID = 15;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


//- PERMUTATION MARKER -\\

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_default

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_default {
  RenderStateContainerID = 16;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_default

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_default

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_Fullbright {
  RenderStateContainerID = 17;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_Fullbright

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_Fullbright

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_Lightgrid {
  RenderStateContainerID = 18;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_Lightgrid

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_Lightgrid

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_LightgridSimple {
  RenderStateContainerID = 19;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_LightgridSimple

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_LightgridSimple

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_Lightmap {
  RenderStateContainerID = 20;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 2;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Lightmap";
    texturetype = lightmap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_Lightmap

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_Lightmap

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_LightmapDot3 {
  RenderStateContainerID = 21;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 4;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "Lightmap1";
    texturetype = lightmap;
    textureindex = 1;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "Lightmap2";
    texturetype = lightmap;
    textureindex = 2;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 3 = {
    samplername = "Lightmap3";
    texturetype = lightmap;
    textureindex = 3;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_LightmapDot3

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_LightmapDot3

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_PointLight {
  RenderStateContainerID = 22;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 2;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_PointLight

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_PointLight

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_SpotLight {
  RenderStateContainerID = 23;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "ProjTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = border,border,border;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_SpotLight

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_SpotLight

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_ProjPointLight {
  RenderStateContainerID = 24;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "ProjTex";
    texturetype = cubemap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_ProjPointLight

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_ProjPointLight

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_DirectionalLight {
  RenderStateContainerID = 25;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_DirectionalLight

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_DirectionalLight

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_PointLight_Shadow {
  RenderStateContainerID = 26;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 2;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_PointLight_Shadow

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_PointLight_Shadow

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_SpotLight_Shadow {
  RenderStateContainerID = 27;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "ProjTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = border,border,border;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_SpotLight_Shadow

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_SpotLight_Shadow

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_ProjPointLight_Shadow {
  RenderStateContainerID = 28;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 3;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "AttenTex";
    texturetype = custom;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 2 = {
    samplername = "ProjTex";
    texturetype = cubemap;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = clamp,clamp,clamp;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_ProjPointLight_Shadow

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_ProjPointLight_Shadow

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER RL_GemShader.forward_DirectionalLight_Shadow {
  RenderStateContainerID = 29;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 115;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 129;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD


#define PERMUTATION_DirectionalLight_Shadow

#include <shaders/SkinningVS.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif


#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#if defined(_VISION_DX11)

  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float4    contextCP         : packoffset(c12);
    float4    cameraPosition    : packoffset(c17);  // eye position
    float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  }
  
  cbuffer g_GlobalConstantBufferObject : register (b1)
  {
    float4x4  matMV             : packoffset(c0);   // model view matrix
    float4x4  matMVP            : packoffset(c4);   // model view projection matrix
    float4x4  matM2WS           : packoffset(c8);   // model to worldspace matrix
    float4    LightmapScaleOfs  : packoffset(c13);  // model UV to lightmap
  }
  
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    #if defined(PROJECTOR_UV)
      float4 PrimaryColor : packoffset(c0);
      float4 RefPlaneS    : packoffset(c1);
      float4 RefPlaneT    : packoffset(c2);
      float4 RefPlaneQ    : packoffset(c3);
      float4 RefPlaneAtt  : packoffset(c4);
    #else
      float4 LightPos : packoffset(c0);
      #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
        float4 RefPlaneX : packoffset(c1);
        float4 RefPlaneY : packoffset(c2);
        float4 RefPlaneW : packoffset(c3);
      #endif
    #endif
  }

  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    cbuffer g_GlobalConstantBufferTerrain : register (b3)
    {
      float4 SectorScaleOfs   : packoffset(c0); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
    }
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)

#else
	float4x4 matMV        : register(c0);
	float4x4 matMVP       : register(c8);
	float4x4 matM2WS      : register(c20);
	float3 cameraPosition : register(c31);

	float4 contextCP      : register(c24);
  
  float4 LightmapScaleOfs : register(c60);
  
	#ifdef USE_FOGCOORD
	  float4 fogParamVS : register(c62);
	#endif

	#if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 SectorScaleOfs   : register(c38); // maps incoming sector xy [0..1] to world space xy position; xy: scaling, zw:ofs
  #endif // defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	
  #if defined(PROJECTOR_UV)
      float4 PrimaryColor : register(c64);
      float4 RefPlaneS    : register(c65);
      float4 RefPlaneT    : register(c66);
      float4 RefPlaneQ    : register(c67);
      float4 RefPlaneAtt  : register(c68);
  #else
    float4 LightPos : register(c64);
    #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow)
      float4 RefPlaneX : register(c66);
      float4 RefPlaneY : register(c67);
      float4 RefPlaneW : register(c68);
    #endif
  #endif

#endif
struct VS_IN                   
{           
  float3 ObjPos   : POSITION;
  float3 Normal   : NORMAL;
  
  #ifdef USE_COLOR
    float4 Color  : COLOR0;
  #endif  
  
  #ifdef USE_UV0
    float2 UV0    : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
    float2 UV1    : TEXCOORD1;
  #endif
  
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
  #endif

  SKINNING_VERTEX_STREAMS
};                                           

struct VS_OUT                                 
{                           
  #ifdef _VISION_DX11
  	float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    float4 Color : COLOR0;
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif
    float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif

  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};                                             

#ifdef USE_SKINNING
  VS_OUT vs_main_skinning(VS_IN In)
#else
  VS_OUT vs_main( VS_IN In )
#endif
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
	  
  #ifndef USE_SKINNING
	  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
	    float4 ObjPos = float4(In.ObjPos.x,In.ObjPos.y,In.ObjPos.z,1.0);
	    ObjPos.xy = ObjPos.xy*SectorScaleOfs.xy + SectorScaleOfs.zw;
	  #else
	    float4 ObjPos = float4(In.ObjPos, 1.0f);
	  #endif
  #else
  	float4 ObjPos;
  	PREPARE_SKINNING(In.BoneIndices);
  	TRANSFORM_OBJECT_POS(ObjPos, In.ObjPos, In.BoneWeight);
  #endif
	 
  #if defined(PROJECTOR_UV) && defined(PERMUTATION_Terrain)
    float4 worldPos = ObjPos;
  #else
	  float4 worldPos = float4(mul(matM2WS, ObjPos).xyz, 1.0);
  #endif 

  #ifdef PROJECTOR_UV
   	Out.Color = PrimaryColor;
  	float distq = dot(worldPos, RefPlaneQ);
  	float dists = dot(worldPos, RefPlaneS);
  	float distt = dot(worldPos, RefPlaneT);
  	Out.UVProjAndAttenuation.x = 0.5 * distq + dists;
  	Out.UVProjAndAttenuation.y = 0.5 * distq + distt;
  	Out.UVProjAndAttenuation.w = distq;
  	Out.UVProjAndAttenuation.z = dot(worldPos, RefPlaneAtt); // Attenuation is stored in the z component
  #endif
  
  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos.xyz;
  #endif  
  
  Out.ProjPos = mul(matMVP, float4(ObjPos.xyz, 1.0f));  
  Out.ScreenPosition = Out.ProjPos;
  Out.ScreenPosition.y = -Out.ScreenPosition.y;
  Out.ScreenPosition.z = GetLinearDepth(mul(matMV, float4(ObjPos.xyz, 1.0f)).z, contextCP.y);

  #ifdef USE_UV0  
    Out.UV0AND1.x = In.UV0.x;
    Out.UV0AND1.y = In.UV0.y;
  #endif
  
  #ifdef USE_COLOR
    Out.Color = In.Color;
  #endif
  
  #ifdef USE_UV1  
    Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
  #endif

  #ifdef USE_SKINNING
    TRANSFORM_OBJECT_NORMAL(objectSpaceNormal, In.Normal, In.BoneWeight);
  #endif

  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)matM2WS , objectSpaceNormal) );
  
  #ifdef USE_TANGENT

    float3 Tangent;
    #ifndef USE_SKINNING
      Tangent = In.Tangent;
    #else
      TRANSFORM_OBJECT_TANGENT(Tangent, In.Tangent, In.BoneWeight);
    #endif

    Out.Tangent = normalize(mul((float3x3)matM2WS, Tangent));
    Out.BiTangent = ComputeBiNormal(Out.Tangent, Out.Normal, GetHandednessCorrection(In.Tangent));
  #endif
  
  #ifdef USE_FOGCOORD
    Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
  #endif
  
  #ifdef USE_LIGHT_WS
    Out.LightWS.xyz = LightPos.xyz - worldPos.xyz;
  #endif

  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS.xyz,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS.xyz,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS.xyz,RefPlaneW.xyz);
  #endif
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, worldPos);
    Out.ProjTexCoord.y = dot(RefPlaneY, worldPos);
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, worldPos);
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
    Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(cameraPosition-worldPos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
    Out.EyeDirAndDepth.w = Out.ScreenPosition.z;
  #endif 

  return Out;                              
}

  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Havok

#define PERMUTATION_DirectionalLight_Shadow

#include <shaders/VisionCommon.inc>
#include <shaders/ShaderHelpers.inc>

#if defined(PERMUTATION_PointLight_Shadow) || defined(PERMUTATION_SpotLight_Shadow) || defined(PERMUTATION_ProjPointLight_Shadow) || defined(PERMUTATION_DirectionalLight_Shadow)
	#define USE_SHADOWTEX_LIGHTING
#endif

#define USE_UV0
#define LIGHTING_FUNCTIONS
#define USE_TANGENT
#define USE_EYEDIR
#define USE_WORLD_POSITION
#define USE_UV1
#define USE_LIGHT_WS
#define USE_SPECULAR
#define USE_FORWARDFOG
#define USE_FOGCOORD

#ifdef PREVIEW
			
			texture Base_Texture; //TEX 
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX10
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX 
			#endif

			#endif




#ifdef PERMUTATION_Lightmap
				#ifdef _VISION_DX10
				Texture2D Lightmap : register(t1);
				sampler Lightmap_Sampler : register(s1);
				#else
				sampler2D Lightmap : register(s1);
				#endif
			#endif
			
			#ifdef PERMUTATION_LightmapDot3
			
				#ifdef _VISION_DX10

				Texture2D Lightmap1 : register(t2);
				Texture2D Lightmap2 : register(t3);
				Texture2D Lightmap3 : register(t4);
				
				sampler Lightmap1_Sampler : register(s2);
				sampler Lightmap2_Sampler : register(s3);
				sampler Lightmap3_Sampler : register(s4);

				#else
				sampler2D Lightmap1 : register(s2);
				sampler2D Lightmap2 : register(s3);
				sampler2D Lightmap3 : register(s4);
				#endif
			#endif
			
			#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					Texture2D ProjTex : register(t6);

					sampler AttenTex_Sampler : register(s5);
					sampler ProjTex_Sampler : register(s6);
				#else
					sampler2D AttenTex : register(s5);
					sampler2D ProjTex : register(s6);
				#endif
			#endif
			
			#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
				
				#ifdef _VISION_DX10
					Texture2D AttenTex : register(t5);
					sampler AttenTex_Sampler : register(s5);
				#else
					sampler2D AttenTex : register(s5);
				#endif
			#endif
			
			#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
			
				#ifdef _VISION_DX10
				Texture2D AttenTex : register(t7);
				TextureCube ProjTex : register(t6);	

				sampler AttenTex_Sampler : register(s5);
				sampler ProjTex_Sampler : register(s6);	
				#else
					sampler2D AttenTex : register(s5);
					samplerCUBE ProjTex : register(s6);				
				#endif
			#endif			
			
			#ifdef USE_SHADOWTEX_LIGHTING
			
				#ifdef _VISION_DX10
			    Texture2D   ShadowTex         : register(t8);
				sampler     ShadowTex_Sampler  : register(s7);
				#else
				sampler2D   ShadowTex         : register(s7);
				#endif
	
			#endif




#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams : packoffset(c0); // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  #ifndef DEFERRED_RENDERING
    float4 LightRadius : packoffset(c1); // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
    #endif
	  #if defined(PERMUTATION_DirectionalLight_Shadow) || defined(PERMUTATION_DirectionalLight)
        float3 LightDirPS   : packoffset(c3);
    #endif  
    #ifdef USE_SHADOWTEX_LIGHTING
      float2 InvScreenSize : packoffset(c4);
    #endif 	  
	  
    #ifndef DEFERRED_RENDERING
      float4 LightColor : packoffset(c2); // xyz: color with pre-multiplied light multiplier
    #else
      float3 MaterialAmbient : packoffset(c1);
    #endif

    #ifdef DEFERRED_RENDERING
      float  AlphaThreshold : packoffset(c2);
      float  GlobalAmbientMultiplier : packoffset(c3);
	    float  gMaterialIndex : packoffset(c4);
    #endif

    // If you add more vision related constants make sure to adjust
    // the packoffset value in the ShaderGenerator!
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    gFogColor     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

  float4 LightmapMultiplier : register(c0);

  #ifdef USE_FOGCOORD
    float4 gFogColor : register(c1);
  #endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

  #if defined(_VISION_PS3) || defined(_VISION_PSP2) || defined(_VISION_WIIU) || defined(_VISION_GLES2)
	  float4 MaterialParams : register(c32);
    #ifndef DEFERRED_RENDERING
  	  float4 LightPos : register(c64);
	    float4 LightColor:register(c33);
	    float4 LightRadius:register(c34);
      float3 LightDirPS  : register(c35);
    #endif
	
		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize : register(c36);
		#endif
	
	#else
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
    #ifndef DEFERRED_RENDERING
	    float4 LightPos;
	    float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	    float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	    float3 LightDirPS;
    #endif

		#ifdef USE_SHADOWTEX_LIGHTING
			float2 InvScreenSize;
		#endif
	#endif

	#ifdef DEFERRED_RENDERING
	  float4 AlphaThreshold : register(c34);
	  float  GlobalAmbientMultiplier : register(c35);
	  #undef USE_LIGHT_WS // for security only

    float  gMaterialIndex : register(c36);
    float3 MaterialAmbient : register(c33);
  #endif
  
#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = (res.diffuse + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
	
    #ifdef USE_SPECULAR
 	    float4 SpecMul = float4(SpecularColor.rgb, 1.0);
 	    SpecMul *= SpecularMultiplier;
 	    result += res.specular*SpecMul;
    #endif
		
		result.a = Opacity;
		
		return result;
	}
	
	float4 Lighting_LightGridSimple( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{                          
		float DotProd = max(dot(Normal, Light2.xyz), 0.0);
		float3 lightColor = Light0.xyz + Light1.xyz * DotProd + AmbientColor;		
		float3 result = lightColor * DiffuseColor.rgb;

    #ifdef USE_SPECULAR
	    float SpecProd = GetSpecularIlluminationPoint(EyeNorm + Light2.xyz, Normal, SpecularExponent);
      result += (SpecProd * SpecularMultiplier) * Light1.xyz * SpecularColor;
    #endif

		return float4(result, Opacity);
	}
	
	#ifdef PERMUTATION_LightmapDot3
	
  	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
  	{
  		float4 cLightmap1 = vTex2D(Lightmap1, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap2 = vTex2D(Lightmap2, Lightmap1_Sampler, LightmapCoord);
  		float4 cLightmap3 = vTex2D(Lightmap3, Lightmap1_Sampler, LightmapCoord);
  		
  		LIGHT_RESULT_SPEC difspec = GetLightmapDot3LightingSpec(Normal, cLightmap1, cLightmap2, cLightmap3, EyeDir, SpecularExponent);
  		float4 cResColor = (difspec.diffuse * LightmapMultiplier.x + float4(AmbientColor.xyz, 0.0))*DiffuseColor;
  		
     	#ifdef USE_SPECULAR
     	  //modulate the specular lighting (either by color or float)
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		SpecMul *= SpecularMultiplier;
     		cResColor.rgb += difspec.specular.rgb * SpecMul.rgb;
     	#endif
  		cResColor.a = Opacity;
  		
  		return cResColor;
  	}
	
	#endif
	
	#if defined(PERMUTATION_PointLight) || defined(PERMUTATION_PointLight_Shadow)
	
  	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
  	{
  	
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader		
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0)).x; //custom attenuation curve texture
    
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec, Normal));
  		
  		float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;			
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif	
	
	#if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
	
  	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTex2Dproj(ProjTex, ProjTex_Sampler, ProjTexCoord); //2D spotlight projector
  
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);		   
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
     	#ifdef USE_SPECULAR
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * LightInt * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
     	#endif
  		ResColor*=saturate(sign(ProjTexCoord.w));
  		
  		return float4(ResColor.rgb, Opacity);
  	}
	
	#endif
	
	#if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)

  	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
  	{
  		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
  		float LightInt = vTex2D(AttenTex, AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
  		float4 ProjLightCol = LightColor * vTexCUBE(ProjTex, ProjTex_Sampler, ProjDir); // Cubemap projector
  		
  		float3 NormLightVec = normalize(LightWS);
  		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal));
  
  		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
  		
    	#ifdef USE_SPECULAR
    		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    		SpecProd *= SpecularMultiplier;
    		SpecProd = saturate(SpecProd * LightInt * DotProd);
    		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));
    	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#if defined(PERMUTATION_DirectionalLight) || defined(PERMUTATION_DirectionalLight_Shadow)
	
  	float4 Lighting_DirectionalLight(float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir)
  	{
  		float3 NormLightVec = -LightDirPS;
  		float DotProd = saturate(dot(NormLightVec.xyz, Normal.xyz));
  		float4 ResColor = DiffuseColor * LightColor * DotProd;
  
     	#ifdef USE_SPECULAR
     		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
     		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
     		SpecProd *= SpecularMultiplier;
     		SpecProd = saturate(SpecProd * DotProd);
     		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
     	#endif
  		
  		return float4(ResColor.rgb, Opacity);	
  	}
	
	#endif
	
	#ifdef USE_SHADOWTEX_LIGHTING
	
  	inline float4 GetShadowTexValue(float4 ScreenPosition)
  	{
      float2 ScreenTex = GetScreenTexPos(ScreenPosition, InvScreenSize);
  		#ifdef _VISION_XENON
  		  // Note: shadow information is only stored in the
  		  //   green channel, thus we avoid to overwrite the
  		  //   stencil values in EDRAM on xbox360 in case of
  		  //   interleaved shadow map rendering
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).yyy, 1.0);
  		#else
  		  return float4(vTex2D(ShadowTex, ShadowTex_Sampler, ScreenTex).xyz, 1.0);
  		#endif		
  	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
  #include <shaders/DeferredShadingHelpers.inc>
#endif

struct PS_IN
{
  #ifdef _VISION_DX11
    float4 ProjPos  : SV_Position;
  #else
    float4 ProjPos  : POSITION;
  #endif
  
  #if defined(USE_COLOR) || defined(PROJECTOR_UV)
    #ifdef _VISION_XENON
      float4 Color    : COLOR0_center;
    #else  
      float4 Color    : COLOR0;
    #endif
  #endif
  
  #if defined( USE_UV0 ) || defined( USE_UV1 )
    float4 UV0AND1 : TEXCOORD0;
  #endif

  float3 Normal  : TEXCOORD1;
  #ifdef USE_TANGENT
    float3 Tangent : TEXCOORD2;
    float3 BiTangent: TEXCOORD3;
  #endif
  
  #ifdef PROJECTOR_UV
    float4 UVProjAndAttenuation : TEXCOORD4;
  #endif

  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_SpotLight_Shadow)
    float4 ProjTexCoord : TEXCOORD4;
  #endif
  
  #if defined(PERMUTATION_ProjPointLight) || defined(PERMUTATION_ProjPointLight_Shadow)
    float3 ProjDir : TEXCOORD4;
  #endif  
  
  #if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
    float4 fogCoordAndWorldPos : TEXCOORD5;
  #endif
  
  float4 ScreenPosition : TEXCOORD6;

  #if defined(USE_LIGHT_WS)
    float3 LightWS : TEXCOORD7;
  #endif
  
  #ifdef DEFERRED_RENDERING
    float4 EyeDirAndDepth : TEXCOORD7;
  #endif

};

inline float2 GetScreenTexCoords(PS_IN In)
{
  return (In.ScreenPosition.xy / In.ScreenPosition.w) * 0.5 + 0.5;
}

#ifdef DEFERRED_RENDERING
	PS_OUT ps_main( PS_IN In )
#else
  float4 ps_main( PS_IN In ) : SV_Target
#endif
  {
 
  #ifdef USE_FOGCOORD
	  float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	  float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    #ifdef DEFERRED_RENDERING
      float3 EyeDir = normalize(In.EyeDirAndDepth.xyz);
    #else
      float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
    #endif
  #endif
  
  #ifdef PREVIEW
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else			
			float4 VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a = vTex2D( BaseTexture, BaseTexture_Sampler, In.UV0AND1.xy );
			#endif
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.g
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.b
*/
/*!float
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.a
*/
/*!float4
VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a
*/
//! MARKER - e1ebe38c69ee498db791c40800810b07

/*!float4
float4(1,1,1,1)
*/
//! MARKER - 00282237ff04433690db2ff812210809

/*!float
1
*/
//! MARKER - 6f5402c49a774c0bb191fc38eb15ef5b
float VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663 = dot(float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), float3(0.299, 0.587, 0.114));
			float4 VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26 = lerp(float4(VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, VAR_Desaturate_cd7f29222f6c4c0ba5a49b054b373663.x, float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ).a), float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r, VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a.r ), saturate(1));
/*!float4
VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26
*/
//! MARKER - c847018f2a064ad2955c455cb2e14750
float4 VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83 = (1.0 - VAR_Desaturate_ab5a64a452ec4b8f8b1db929d1a7ef26);
/*!float4
VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83
*/
//! MARKER - e459d67f1fef4b5d93a9ddbdeed4f6e2

#ifdef PERMUTATION_default
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(0.0f, 0.0f, 0.0f, 0.0f);
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Fullbright
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a;
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightgrid
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGrid( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightgridSimple
#ifdef PREVIEW
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a + float4(gGlobalAmbient.xyz, 0)*0.5f;
			#else
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightGridSimple( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir );
			#endif
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_Lightmap
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a * ((vTex2D(Lightmap, Lightmap_Sampler, In.UV0AND1.zw) * LightmapMultiplier.x).xyz + gGlobalAmbient.xyz), 1.0 );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_LightmapDot3
float3 VAR_Lighting_974a27c0f85444338c04ab9585e946f1 = normalize(float3(0.0, 0.0, 1.0));
			float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_LightmapDot3( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, VAR_Lighting_974a27c0f85444338c04ab9585e946f1, 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, normalize(GetVectorInTextureSpace(EyeDir, In.Tangent, In.Normal, In.BiTangent)), In.UV0AND1.zw );
			
			#ifdef USE_FORWARDFOG
			VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = float4(lerp(VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.rgb, gFogColor.rgb, saturate(FogCoord)),VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5.a);
			#endif
#endif

#ifdef PERMUTATION_PointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition );
#endif

#ifdef PERMUTATION_SpotLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord );
#endif

#ifdef PERMUTATION_ProjPointLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir );
#endif

#ifdef PERMUTATION_DirectionalLight
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir);
#endif

#ifdef PERMUTATION_PointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_PointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, In.LightWS, WorldPosition ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_SpotLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_Spotlight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjTexCoord ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_ProjPointLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_ProjPointLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir, In.LightWS, In.ProjDir ) * GetShadowTexValue(In.ScreenPosition);
#endif

#ifdef PERMUTATION_DirectionalLight_Shadow
float4 VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 = Lighting_DirectionalLight( VAR_BaseTexture_df4978f52f4d492bbb01ad0943bbaa6a, normalize(TangentToWorldSpace(float3(0.0, 0.0, 1.0), In.Normal, In.Tangent, In.BiTangent)), 64.0, float3(float4(1,1,1,1).r, float4(1,1,1,1).g, float4(1,1,1,1).b ), (dot(VAR_OneMinus_aeb4aabb0bad495bbda4c9d512dadb83.rgba, 0.25)), gGlobalAmbient.xyz, 1.0, EyeDir) * GetShadowTexValue(In.ScreenPosition);
#endif

/*!float4
VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5
*/
//! MARKER - 954e0bfcf22641948e1b4adbe0d16dd9
float4 VAR_Saturate_713e2f81d74f4611bca01a079dfb485a = saturate( VAR_Lighting_d916bceeeecd4f5cbc8ee9f6480a4bb5 );
/*!float4
VAR_Saturate_713e2f81d74f4611bca01a079dfb485a
*/
//! MARKER - 7ac913665d4e48cc8ce6e1bf652f996a
return VAR_Saturate_713e2f81d74f4611bca01a079dfb485a;
//! MARKER - 2ede00535b644e06b35649648dd56ff8


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

//////////////////////////////////////////////////////////////////////////////

EFFECT shader01.forward {
  DESCRIPTION = {};
  PARAMCOMMENT={"GlowMultiplier","GlowMultiplier","3",float,none,""};
  PARAMCOMMENT={"GlowMap","The name of the texture","\flare07.dds",texture,texturefile,""};
  TECHNIQUE "shader01.forward"
  {
    passes="shader01.forward";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_default"
  {
    inclusionTags="DEFAULT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_default";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_Fullbright"
  {
    inclusionTags="FULLBRIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_Fullbright";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_Lightgrid"
  {
    inclusionTags="LIGHTGRID;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_Lightgrid";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_LightgridSimple"
  {
    inclusionTags="LIGHTGRIDSIMPLE;NOFOG;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_LightgridSimple";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_Lightmap"
  {
    inclusionTags="LIGHTMAP;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_Lightmap";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_LightmapDot3"
  {
    inclusionTags="LIGHTMAPDOT3;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_LightmapDot3";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_PointLight"
  {
    inclusionTags="POINTLIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_PointLight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_SpotLight"
  {
    inclusionTags="SPOTLIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_SpotLight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_ProjPointLight"
  {
    inclusionTags="PROJPOINTLIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_ProjPointLight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_DirectionalLight"
  {
    inclusionTags="DIRECTIONALLIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_DirectionalLight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_PointLight_Shadow"
  {
    inclusionTags="POINTLIGHT;POINTLIGHT_SHADOW;SHADOWMAP;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_PointLight_Shadow";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_SpotLight_Shadow"
  {
    inclusionTags="SHADOWMAP;SPOTLIGHT;SPOTLIGHT_SHADOW;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_SpotLight_Shadow";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_ProjPointLight_Shadow"
  {
    inclusionTags="PROJPOINTLIGHT;PROJPOINTLIGHT_SHADOW;SHADOWMAP;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_ProjPointLight_Shadow";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "shader01.forward_DirectionalLight_Shadow"
  {
    inclusionTags="DIRECTIONALLIGHT;DIRECTIONALLIGHT_SHADOW;SHADOWMAP;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="shader01.forward_DirectionalLight_Shadow";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT RL_GemShader.forward {
  DESCRIPTION = {};
  TECHNIQUE "RL_GemShader.forward"
  {
    passes="RL_GemShader.forward";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_default"
  {
    inclusionTags="DEFAULT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_default";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_Fullbright"
  {
    inclusionTags="FULLBRIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_Fullbright";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_Lightgrid"
  {
    inclusionTags="LIGHTGRID;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_Lightgrid";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_LightgridSimple"
  {
    inclusionTags="LIGHTGRIDSIMPLE;NOFOG;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_LightgridSimple";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_Lightmap"
  {
    inclusionTags="LIGHTMAP;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_Lightmap";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_LightmapDot3"
  {
    inclusionTags="LIGHTMAPDOT3;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_LightmapDot3";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_PointLight"
  {
    inclusionTags="POINTLIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_PointLight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_SpotLight"
  {
    inclusionTags="SPOTLIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_SpotLight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_ProjPointLight"
  {
    inclusionTags="PROJPOINTLIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_ProjPointLight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_DirectionalLight"
  {
    inclusionTags="DIRECTIONALLIGHT;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_DirectionalLight";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_PointLight_Shadow"
  {
    inclusionTags="POINTLIGHT;POINTLIGHT_SHADOW;SHADOWMAP;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_PointLight_Shadow";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_SpotLight_Shadow"
  {
    inclusionTags="SHADOWMAP;SPOTLIGHT;SPOTLIGHT_SHADOW;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_SpotLight_Shadow";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_ProjPointLight_Shadow"
  {
    inclusionTags="PROJPOINTLIGHT;PROJPOINTLIGHT_SHADOW;SHADOWMAP;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_ProjPointLight_Shadow";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
  TECHNIQUE "RL_GemShader.forward_DirectionalLight_Shadow"
  {
    inclusionTags="DIRECTIONALLIGHT;DIRECTIONALLIGHT_SHADOW;SHADOWMAP;VMATERIAL_NORMALMAP;VMATERIAL_PARALLAX;VMATERIAL_REFMAP;VMATERIAL_SPECULAR";
    passes="RL_GemShader.forward_DirectionalLight_Shadow";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

